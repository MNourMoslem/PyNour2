#include "nour/nour.h"
#include "../src/nour/niter.h"
#include "../src/nour/node_core.h"

/**
 * Template for a basic mathematical operation between two input nodes.
 *
 * Function Name:
 *   - `NMath_%OP%_%T%`
 *   - `%OP%`: Represents the operation's name (e.g., "add", "subtract").
 *   - `%T%`: Represents the data type of the operation (e.g., `NR_INT32`, `NR_UINT64`).
 *
 * Macros:
 *   - `%OPC%`: The uppercase version of the operation name, used to map to the specific operation implementation.
 *   - `%NT%`: Represents the low-level C typedef corresponding to `%T%` (e.g., `nr_int32` for `NR_INT32`).
 *
 * Arguments:
 *   - `NFuncArgs* args`: Contains:
 *     - `nodes`: An array of pointers to the input `Node` objects (`n1`, `n2`).
 *     - `out`: A pointer to the output `Node` object (`out`).
 *
 * Functionality:
 *   - This template defines a mathematical operation between two `Node` objects (`n1` and `n2`),
 *     storing the result in the `out` `Node`.
 *   - Handles different data layouts (contiguous, strided, or arbitrary shapes) using `NIter` and `NMultiIter`.
 *   - Efficiently processes data when the input nodes are:
 *     - Both contiguous and of the same shape.
 *     - Partially contiguous (one node is contiguous).
 *     - Non-contiguous, requiring multi-iterator support.
 *
 * Modes of Operation:
 *
 * 1. **Contiguous and Same Shape:**
 *    - When both `n1` and `n2` are contiguous and have the same shape (`Node_SameShape`):
 *      - Iterates over data using a simple loop for maximum performance.
 *
 * 2. **Partially Contiguous:**
 *    - If only one of the nodes is contiguous:
 *      - Uses `NIter` (strided mode) for the non-contiguous node.
 *      - The iterator steps through the non-contiguous node while the contiguous node is accessed directly.
 *
 * 3. **Non-Contiguous or Different Shapes:**
 *    - For fully non-contiguous or differently shaped nodes:
 *      - Utilizes `NIter` for both nodes.
 *      - The iterators handle arbitrary strides and memory layouts.
 *      - Ensures the output shape matches the broadcasting rules.
 *
 * 4. **Broadcasting:**
 *    - If `n1` and `n2` require broadcasting:
 *      - Uses `NMultiIter`, which supports multi-dimensional iteration over broadcasted inputs.
 *      - Iterates through all elements, applying the operation while respecting broadcasting rules.
 *
 * Operation Implementation:
 *   - The macro `NMATH_%NAMEC%` defines the operation to perform.
 *   - Example for `add`:
 *     ```
 *     #define NMATH_ADD(result, a, b) (result) = (a) + (b)
 *     ```
 *
 * Return Value:
 *   - Returns `0` on success.
 *   - Returns `-1` if memory allocation fails or the input nodes cannot be iterated over properly.
 */

 NR_PRIVATE NR_DTYPE
_CheckDtypes_3Nodes(Node* c, Node* a, Node* b){
    NR_DTYPE at = a->dtype.dtype;
    NR_DTYPE bt = b->dtype.dtype;
    NR_DTYPE outt = at == bt ? at : NTools_BroadcastDtypes(at, bt);
    NR_DTYPE ct = c ? c->dtype.dtype : outt;

    if (outt != ct){
        char outt_str[10];
        char ct_str[10];
        NDtype_AsStringVarType(outt, outt_str);
        NDtype_AsStringVarType(ct, ct_str);

        NError_RaiseError(
            NError_ValueError,
            "out node must have the same dtype as the input nodes"
            "dtype or the broadcasted dtype, got %s expected %s",
            outt_str, ct_str
        );
        return -1;
    }

    return outt;
}

NR_PRIVATE Node*
_NMath_Func_2in1out(Node* c, Node* a, Node* b, NFunc func_list[]){
    NR_DTYPE outt = _CheckDtypes_3Nodes(c, a, b);
    if (outt < NR_BOOL){
        return NULL;
    }

    NFunc func = func_list[outt];

    Node* in[] = {a, b};
    NFuncArgs args = {
        .nodes = in,
        .out = c,
        .n_nodes = 2
    };

    if (func(&args) != 0){
        return NULL;
    }
    return args.out;
}

//Template//
NR_PUBLIC int
NMath_%OP%_%T%(NFuncArgs* args){
    Node* n1 = args->nodes[0];
    Node* n2 = args->nodes[1];
    Node* out = args->out;

    int ss = Node_SameShape(n1, n2);
    if (!out && ss){
        out = Node_NewEmpty(n1->ndim, n1->shape, n1->dtype.dtype);
        if (!out){
            return -1;
        }
    }

    int n1c = NODE_IS_CONTIGUOUS(n1);
    int n2c = NODE_IS_CONTIGUOUS(n2);
    int outc = out ? NODE_IS_CONTIGUOUS(out) : 0;

    if (ss && outc){
        if (n1c & n2c){
            int nitems = Node_NItems(n1);
            for (int i = 0; i < nitems; i++){
                *((%NT%*)out->data + i) = NMATH_%OPC%(  *((%NT%*)n1->data + i), 
                                                        *((%NT%*)n2->data + i)  );
            }
        }
        else if (n1c | n2c){
            Node* con_n = NODE_IS_CONTIGUOUS(n1) ? n1 : n2;
            Node* str_n = NODE_IS_CONTIGUOUS(n1) ? n2 : n1;
            NIter it;
            NIter_FromNode(&it, str_n, NITER_MODE_STRIDED);

            int i = 0;
            NIter_ITER(&it);
            while (NIter_NOTDONE(&it))
            {
                *((%NT%*)out->data + i) = NMATH_%OPC%(  *(%NT%*)NIter_ITEM(&it), 
                                                        *((%NT%*)con_n->data + i)  );

                NIter_NEXT(&it);
                i++;
            }   
        }
        else{
            NIter it1, it2;
            NIter_FromNode(&it1, n1, NITER_MODE_NONE);
            NIter_FromNode(&it2, n2, NITER_MODE_NONE);

            int i = 0;

            NIter_ITER(&it1);
            NIter_ITER(&it2);
            while (NIter_NOTDONE(&it1))
            {
                *((%NT%*)out->data + i) = NMATH_%OPC%(  *(%NT%*)NIter_ITEM(&it1),
                                                        *(%NT%*)NIter_ITEM(&it2)   );

                NIter_NEXT(&it1);
                NIter_NEXT(&it2);
                i++;
            }
        }
    }
    else{
        NMultiIter mit;
        if (NMultiIter_New(args->nodes, 2, &mit) != 0){
            return -1;
        }

        if (!out){
            out = Node_NewEmpty(mit.out_ndim, mit.out_shape, n1->dtype.dtype);
            if (!out){
                return -1;
            }
        }

        int i;
        NMultiIter_ITER(&mit);
        while (NMultiIter_NOTDONE(&mit))
        {
            *((%NT%*)out->data + i) = NMATH_%OPC%(  *(%NT%*)NMultiIter_ITEM(&mit, 0),
                                                    *(%NT%*)NMultiIter_ITEM(&mit, 1)  );
        
            i++;
            NMultiIter_NEXT(&mit);
        }
    }
    args->out = out;
    return 0;
}

//Template//
NR_STATIC NFunc __NMATH_%OPC%_METHODS__[] = {
%METHODS%
};

//Template//
NR_PUBLIC Node*
NMath_%OP%(Node* c, Node* b, Node*a){
    return _NMath_Func_2in1out(c, b, a, __NMATH_%OPC%_METHODS__);
}